# %%
from collections import deque
from pathlib import Path

import polars as pl
from Bio import Restriction, Seq

from fishtools import Dataset, SAMFrame, gen_fasta, rc
from fishtools.mkprobes.starmap.starmap import test_splint_padlock
from fishtools.mkprobes.utils.sequtils import is_subsequence
from fishtools.utils.pretty_print import printc

primers = pl.read_csv("data/headerfooter.csv")
t7promoter = "TAATACGACTCACTATAGGG"
bits = pl.read_csv("data/readout_ref_filtered.csv")
bits = dict(zip(bits["seq"], bits["id"]))

ds = Dataset("data/human")


ss = Path("starwork2/generated/humanbase_final.txt").read_text().splitlines()


def t7(seq: str):
    """Find the sequence of the RNA generated by the T7 promoter."""
    try:
        idx = seq.index(t7promoter)
        return seq[idx + len(t7promoter) - 3 :]  # First base is G.
    except ValueError:
        ...

    idx = rc(seq).index(t7promoter)
    return rc(seq)[idx + len(t7promoter) - 3 :]


def rt(seq: str, primer: str):
    """Reverse transcribe the RNA sequence given a primer,"""
    try:
        res = rc(seq).index(primer)
    except ValueError:
        raise ValueError("Primer not found.")
    return rc(seq)[res:]


def double_digest(s: str) -> str:
    return Restriction.BamHI.catalyze(Restriction.KpnI.catalyze(Seq.Seq(s))[1])[0].__str__()


def anneal(seq: str, primer: str):
    # Returns span of annealed primer.
    return is_subsequence(rc(primer))(seq)


# %%
def process(seq: str, rt_primer: str, anneal_primer: tuple[str, str]):
    t7ed = t7(seq + "TAGTGAGTCGTATTA")  # complete T7 promoter with PCR primers
    rted = rt(t7ed, rt_primer)

    # Confirm that the annealed sequences can be cut.
    frag1 = anneal(rted, anneal_primer[0])
    frag2 = anneal(rted, anneal_primer[1])
    assert frag1
    assert frag2
    print(f"Annealed at {frag1} and {frag2}.")

    return double_digest(rted)


i = 50
sp = process(
    ss[2 * i],
    primers[0, "header"],
    (rc(primers[0, "header"]), rc(primers[0, "footer"][:-5])),
)
pad = process(ss[2 * i + 1], primers[1, "header"], (rc(primers[1, "header"]), rc(primers[1, "footer"][:-5])))

# %%
df = SAMFrame.from_bowtie(
    gen_fasta(
        # forward handle of splint, last 17 bases of splint are ligation handles
        # first 9 bases of pad are ligation handle
        [sp[3 : -(2 + 8 + 6)], pad[9:29]],
        names=["splint", "padlock"],
    ).getvalue(),
    "data/human/txome",
    seed_length=12,
    threshold=15,
    n_return=200,
    fasta=True,
    no_forward=True,
)
# %%


# %%
sps = set(df.filter(pl.col("name") == "splint").sort("match_consec")["transcript"])
pads = set(df.filter(pl.col("name") == "padlock").sort("match_consec")["transcript"])
filtered = df.filter(pl.col("transcript").is_in(sps & pads)).sort(["transcript", "name"])
assert filtered.select((pl.col("flag") & 16 != 0).all())[0, "flag"]  # reverse strand
print(filtered[["name", "flag", "transcript", "pos"]])

idxs = (filtered[0, "pos"] + filtered[0, "match_consec"], filtered[1, "pos"])
gap = idxs[1] - idxs[0]
assert 0 <= gap < 3  # distance between end of splint and start of padlock less than 3
assert test_splint_padlock(sp[-14:], pad, lengths=(6, 8))


# %%

transcript = ds.ensembl.get_seq(filtered[0, "transcript"])

# %%

start = filtered[0, "pos"]
startpad = filtered[1, "pos"]


def show_starmap(transcript: str, pad: str, splint: str, overhang: int = 16, gap: int = 0):
    space = " " * (len(splint) - overhang - 1)
    # extra 3 bases from padlock end
    printc(space + " " * (gap + 1) + "/---")
    for i in range(3):
        printc(space + ("â†‘" if i == 2 else " ") + (" " * gap) + pad[-(9 - i)])

    # splint-padlock
    for i in range(overhang):
        a, b = splint[-(i + 1)], (pad[-(8 - i)] if i < 8 else pad[i - 8])
        printc(space + a + ("-" if rc(a) == b else " ") * gap + b)
        if i == 7:  # ligation site
            printc(space + "|" + " " * gap + "-")

    combi = splint[:-overhang] + " " * gap + pad[9:35] + "---"
    template = transcript[idxs[0] - 27 : idxs[1] + len(splint) - overhang - 1][::-1]

    # alignment
    printc(combi)
    print("".join("|" if rc(a) == b else " " for a, b in zip(combi, template)))
    print(template)


show_starmap(transcript, pad, sp, gap=gap)

# %%


def visualize_padlock(splint: str, pad: str):
    printc("5-" + splint[-14:-8] + "  " + splint[-8:] + "-3")
    printc("/-" + pad[:6][::-1] + "53" + pad[-8:][::-1] + "-\\")


visualize_padlock(sp, pad)


# %%
def rotate(s: str, r: int):
    return s[r:] + s[:r]


# rotate 9 bases to the left since first bit is split at the padlock junction
(de := deque(pad)).rotate(-9)
rcaed = rc("".join(de))  # reverse complement as a result of RCA
assert len(bits_ := [bits[bit] for bit in bits if rc(bit) in rcaed]) == 3
print(bits_)

# %%
# %%


# %%
df = pl.DataFrame({"seq": ss, "is_pad": [bool(i & 1) for i in range(len(ss))]})
pad = df.filter(pl.col("is_pad"))
# %%
print(pad["seq"][0].index(rc("TAATGGTCTCCTGGC")))

p = pad.select(pl.col("seq").str.slice(109 - 6, 20).str.extract_all(r"\w").list.to_struct()).unnest("seq")

# %%
mapping = {
    "['A', 'C', 'T']": "H",
    "['A', 'G', 'T']": "D",
    "['A', 'C', 'G']": "V",
    "['C', 'G', 'T']": "B",
    "['A', 'C']": "M",
    "['A', 'G']": "R",
    "['A', 'T']": "W",
    "['C', 'G']": "S",
    "['C', 'T']": "Y",
    "['G', 'T']": "K",
    "['A']": "A",
    "['C']": "C",
    "['G']": "G",
    "['T']": "T",
}

rc("".join([mapping[str(sorted(p[c].unique().to_list()))] for c in p.columns]))
# %%
