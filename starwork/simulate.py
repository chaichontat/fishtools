# %%
from collections import deque
from pathlib import Path

import polars as pl
from Bio import Restriction, Seq

from fishtools import Dataset, SAMFrame, gen_fasta, rc
from fishtools.mkprobes.starmap.starmap import test_splint_padlock
from fishtools.mkprobes.utils.sequtils import is_subsequence
from fishtools.utils.pretty_print import printc

primers = pl.read_csv("starwork/primer.txt", separator="\t", has_header=False, new_columns=["name", "seq"])
primers = dict(zip(primers["name"], primers["seq"]))
t7promoter = "TAATACGACTCACTATAGGG"
bits = pl.read_csv("data/readout_ref_filtered.csv")

ds = Dataset("data/mouse")

ss = Path("starwork/tricycle_out.txt").read_text().splitlines()


def t7(seq: str):
    """Find the sequence of the RNA generated by the T7 promoter."""
    try:
        idx = seq.index(t7promoter)
        return seq[idx + len(t7promoter) - 3 :]  # First base is G.
    except ValueError:
        ...

    idx = rc(seq).index(t7promoter)
    return rc(seq)[idx + len(t7promoter) - 3 :]


def rt(seq: str, primer: str):
    """Reverse transcribe the RNA sequence given a primer,"""
    try:
        res = rc(seq).index(primer)
    except ValueError:
        raise ValueError("Primer not found.")
    return rc(seq)[res:]


def digest(seq: str) -> list[int]:
    return Restriction.BsaI.catalyze(Seq.Seq(seq))


def anneal(seq: str, primer: str):
    # Returns span of annealed primer.
    return is_subsequence(rc(primer))(seq)


# %%
def process(seq: str, rt_primer: str, anneal_primer: tuple[str, str]):
    t7ed = t7(seq + "TCGTATTA")  # complete T7 promoter with PCR primers
    rted = rt(t7ed, rt_primer)

    # Confirm that the annealed sequences can be cut.
    frag1 = anneal(rted, anneal_primer[0])
    frag2 = anneal(rted, anneal_primer[1])
    assert frag1
    assert frag2
    assert len(digest(rted[frag1[0] : frag1[1]])) == 2
    assert len(digest(rted[frag2[0] : frag2[1]])) == 2
    print(f"Annealed at {frag1} and {frag2}.")

    digested = digest(rted[frag1[0] : frag2[1]])
    assert len(digested) == 3  # 2 cuts expected resulting in 3 fragments
    return str(digested[1])  # middle fragment


i = 500
sp = process(
    ss[2 * i],
    primers["Splint2-F"],
    (primers["Splint2-Cleave1"], primers["Splint2-Cleave2"]),
)
pad = process(ss[2 * i + 1], primers["Pad2-F"], (primers["Pad2-Cleave1"], primers["Pad2-Cleave2"]))

# %%
df = SAMFrame.from_bowtie(
    gen_fasta(
        # forward handle of splint, last 15 bases of splint are ligation handles
        # first 9 bases of pad are ligation handle
        [sp.split("TGTTGATGAGGTGTTGATGATAA")[1][:-15], pad[9:29]],
        names=["splint", "padlock"],
    ).getvalue(),
    "data/mouse/txome",
    seed_length=12,
    threshold=16,
    n_return=200,
    fasta=True,
    no_forward=True,
)
# %%


# %%
sps = set(df.filter(pl.col("name") == "splint").sort("match_consec")["transcript"])
pads = set(df.filter(pl.col("name") == "padlock").sort("match_consec")["transcript"])
filtered = df.filter(pl.col("transcript").is_in(sps & pads)).sort(["transcript", "name"])
assert filtered.select((pl.col("flag") & 16 != 0).all())[0, "flag"]  # reverse strand
print(filtered[["name", "flag", "transcript", "pos"]])

idxs = (filtered[0, "pos"] + filtered[0, "match_consec"], filtered[1, "pos"])
gap = idxs[1] - idxs[0]
assert 0 <= gap < 3  # distance between end of splint and start of padlock less than 3
assert test_splint_padlock(sp[-12:], pad)


# %%

transcript = ds.ensembl.get_seq(filtered[0, "transcript"])

# %%

start = filtered[0, "pos"]
startpad = filtered[1, "pos"]
printc(" " * (len(sp) - 15 - 1) + " " * (gap + 1) + "/---")
for i in range(3):
    printc(" " * (len(sp) - 15 - 1) + " " * (gap + 1) + pad[-(9 - i)])

for i in range(15):
    a, b = sp[-(i + 1)], (pad[-(6 - i)] if i < 6 else pad[i - 6])
    printc(" " * (len(sp) - 15 - 1) + a + ("-" if rc(a) == b else " ") * gap + b)
    if i == 5:
        printc(" " * (len(sp) - 15 - 1) + "|" + " " * gap + "-")


combi = sp[:-15] + " " * gap + pad[9:35] + "---"
template = transcript[idxs[0] - 27 : idxs[1] + len(sp) - 16][::-1]

printc(combi)
print("".join("|" if rc(a) == b else " " for a, b in zip(combi, template)))
print(template)
# %%


def visualize_padlock(splint: str, pad: str):
    printc("5-" + splint[-12:-6] + "  " + splint[-6:] + "-3")
    printc("/-" + pad[:6][::-1] + "53" + pad[-6:][::-1] + "-\\")


visualize_padlock(sp, pad)


# %%
def rotate(s: str, r: int):
    return s[r:] + s[:r]


# rotate 9 bases to the left since first bit is split at the padlock junction
(de := deque(pad)).rotate(-9)
rcaed = rc("".join(de))  # reverse complement as a result of RCA
assert len(bits_ := [bit for bit in bits["seq"] if rc(bit) in rcaed]) == 3
print(bits_)

# %%
# %%


# %%
df = pl.DataFrame({"seq": ss, "is_pad": [bool(i & 1) for i in range(len(ss))]})
pad = df.filter(pl.col("is_pad"))
# %%
print(pad["seq"][0].index(rc("TAATGGTCTCCTGGC")))

p = pad.select(pl.col("seq").str.slice(109 - 6, 20).str.extract_all(r"\w").list.to_struct()).unnest("seq")

# %%
mapping = {
    "['A', 'C', 'T']": "H",
    "['A', 'G', 'T']": "D",
    "['A', 'C', 'G']": "V",
    "['C', 'G', 'T']": "B",
    "['A', 'C']": "M",
    "['A', 'G']": "R",
    "['A', 'T']": "W",
    "['C', 'G']": "S",
    "['C', 'T']": "Y",
    "['G', 'T']": "K",
    "['A']": "A",
    "['C']": "C",
    "['G']": "G",
    "['T']": "T",
}

rc("".join([mapping[str(sorted(p[c].unique().to_list()))] for c in p.columns]))
# %%
